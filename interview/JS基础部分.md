# JS 基础部分

## 什么是原型/原型链？

原型的本质就是一个对象，当我们在创建一个构造函数之后，这个函数就默认带上了 prototype 属性，这个属性的是用来实现基于原型的继承和属性的共享。当我们通过该构造函数创建实例对象时就会从这个原型属性上继承到该对象的属性。
原型链就是通过原型一层层相互关联的链状结构。

## 作用域与作用域链

作用域是在代码区块中变量的可见性（分三种作用域：全局作用域、函数作用域、块级作用域），当内部执行获取变量的时候，会从最内层作用域向外查找变量，这种向外查找的层级关系即为作用域链

## 讲讲 v8 垃圾回收

1、根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同分代采用不同的回收算法
2、新生代采用空间换时间的 scavenge 算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作
3、老生代使用标记清除和标记整理，标记清除：遍历所有对象标记标记可以访问到的对象（活着的），然后将不活的当做垃圾进行回收。回收完后避免内存的断层不连续，需要通过标记整理将活着的对象往内存一端进行移动，移动完成后再清理边界内存

## 闭包与闭包的作用

引用了其他函数作用域中变量的函数，通常是在嵌套函数中实现的，多用于：内部函数需要调用外部变量等场景，比如：bind 函数，防全局变量污染自执行函数，柯里化函数等

## 讲述浏览器从输入网址到打开网页的整个过程？

```text
1、DNS解析：当你在浏览器中输入网址时，浏览器会向DNS服务器请求解析域名对应的IP地址。

2、建立TCP连接：浏览器会使用HTTP协议与服务器建立TCP连接，建立连接时需要进行三次握手。

3、发送HTTP请求：浏览器向服务器发送HTTP请求，请求中包括请求的方法、URL、协议版本、请求头等信息。

4、服务器处理请求并返回HTTP响应：服务器收到请求后，根据请求的内容进行处理，并返回HTTP响应，响应中包含响应码、响应头、响应体等信息。

5、浏览器接收响应：浏览器收到HTTP响应后，会根据响应头中的信息判断响应体的类型，并进行相应处理。

6、解析HTML并渲染页面：浏览器将HTML解析成DOM树，并根据CSS解析成CSSOM树，然后将DOM树和CSSOM树合并成渲染树，并根据渲染树进行页面渲染，最终呈现给用户。

7、关闭TCP连接：浏览器在完成页面渲染后，会关闭与服务器的TCP连接。

总体来说，浏览器从输入网址到打开网页的整个过程需要进行多个步骤，其中包括DNS解析、建立TCP连接、发送HTTP请求、服务器处理请求并返回HTTP响应、浏览器接收响应、解析HTML并渲染页面，最后关闭TCP连接。
```

## 说一说你理解的 JS 事件循环机制？

```text
JavaScript事件循环机制是一种异步编程模型，它允许JavaScript应用程序在等待I/O操作完成时继续执行其他任务。它的核心是事件循环，其流程如下：

1、JavaScript运行时环境会维护一个事件循环（event loop）的机制，用来监听事件队列中的事件。

2、当JavaScript代码执行到一个异步函数时，这个函数会被添加到事件队列中。

3、事件循环不断地从事件队列中取出事件并执行，直到队列为空。

4、事件循环在取出每个事件时，会先检查该事件是否为异步事件。如果是异步事件，则将其添加到另一个队列中，等待I/O操作完成后再执行。

5、一旦异步事件完成，将其添加到事件队列中，继续等待事件循环执行。

JavaScript事件循环机制的优点在于它不会阻塞代码执行，可以同时处理多个异步事件，从而提高程序的性能和响应能力。
```

详细一点的说法：

```text
JavaScript的事件循环由以下几个部分构成：

1、事件队列(Event queue)：存储所有待处理的事件，每个事件都是一个函数或一个消息。

2、执行栈(Execution stack)：存储当前正在执行的函数调用栈，JavaScript引擎会按照执行栈中的顺序执行函数。

3、任务队列（Task queue）：任务队列如浏览器提供的DOM和XMLHttpRequest API，setTimeout, setInterval。

JavaScript的事件循环执行原理如下：

1、首先执行栈中的代码，直到执行栈为空。

2、如果事件队列中有事件，从事件队列中取出一个事件并执行。

3、如果事件是一个异步事件，将其添加到任务队列(Task queue)中。

4、重复执行步骤1-3，直到事件队列和任务队列都为空。

5、如果任务队列中有任务，按照优先级从高到低依次执行任务。

6、如果任务是一个异步任务，将其添加到任务队列中。

7、重复执行步骤5-6，直到任务队列为空。

JavaScript的事件循环遵循"先进先出"的原则，即事件和任务按照添加的顺序依次执行。同时，JavaScript的事件循环是单线程的，只能执行一个任务或事件，这也是JavaScript中避免竞态条件的重要原因。
```

## ES6 有哪些新能力？

```text
ES6(ES2015)作为一项重大的更新，引入了许多新的语言特性和改进，下面是ES6中一些主要的新内容：

1、箭头函数：箭头函数是一种更简洁的函数声明方式，使用箭头函数可以省略function关键字以及return关键字。

2、解构赋值：解构赋值提供了一种方便的方式，可以从数组或对象中提取多个值并将其赋值给变量。

3、模板字面量：模板字面量提供了一种更方便的方式，可以创建字符串类型的值，而无需使用字符串拼接。

4、默认参数值：ES6允许函数参数设置默认值，当调用函数时，如果未传递参数，则将使用默认值。

5、Rest参数：Rest参数允许将多个参数包装成一个数组，这样可以更方便地处理多个参数。

6、扩展操作符：扩展操作符可以将数组或对象扩展成一组参数，这样可以更方便地传递参数。

7、类和继承：ES6引入了类和继承，使得JavaScript变得更加面向对象，类和继承的使用方式与其他面向对象编程语言相似。

8、模块化：ES6引入了模块化，使得JavaScript中的代码更加可管理和可组织。

9、Promise对象：Promise对象提供了一种处理异步操作的方式，可以更方便地编写异步代码。

10、Symbol类型：Symbol类型是ES6引入的新类型，用于创建唯一的标识符。

11、迭代器和生成器：迭代器和生成器提供了一种更方便的方式，可以处理集合类型数据的迭代和生成。

12、Map和Set类型：Map和Set类型是ES6引入的新类型，提供了更方便的方式，可以存储和操作集合类型数据。

以上是ES6中的一些主要新内容，它们为JavaScript的开发带来了更多的便利和灵活性。
```

## map 类与 Object 有什么区别？

```text
JavaScript中的map类和object有以下区别：

1、map类中的键可以是任何值，而object中的键必须是字符串或符号类型。

2、map类中的键和值是有序的，而object中的键和值是无序的。

3、map类提供了更丰富的API，可以方便地进行各种操作，如遍历、添加、删除、查找等，而object相对简单，只提供了一些基本操作。

4、map类的性能可能会比object略低，但是在某些情况下，使用map类可以让代码更加清晰、可读性更高。

5、map类的内存消耗相对较高，因为它需要额外的数据结构来维护键值对之间的关系，而object不需要。

总的来说，map类适用于需要有序、灵活、操作丰富的键值对数据结构，而object适用于简单的键值对数据结构。
```

## 箭头函数和普通函数（函数声明和函数表达式）的区别

```text
1. 箭头函数没有自己的this，它的this继承自外层的作用域，也就是说，箭头函数的this与外层函数的this保持一致，甚至可以取代外层函数的this。

2. 箭头函数没有arguments对象，所以要获取函数参数需要使用rest参数。

3. 箭头函数不能作为构造函数，不能使用new关键字调用，否则会抛出错误。

4. 箭头函数没有prototype属性，因此不能定义原型方法。

5. 箭头函数不能使用yield关键字，因此不能用作Generator函数。

6. 箭头函数不能使用call、apply、bind等方法改变this的指向，因为箭头函数没有自己的this。

7. 箭头函数的语法比较简洁，可以让代码更加简洁易懂。

总之，箭头函数适用于那些不需要this、arguments、bind等特性的简单函数，而传统函数则适用于复杂函数和需要面向对象编程的场景。
```

## 前端跨域有以下几种方案

```text
1、JSONP：利用script标签的src属性不受同源策略限制的特点，通过向服务器请求一个带有callback参数的js文件来实现跨域请求。

2、CORS（跨域资源共享）：在服务器端配置响应头Access-Control-Allow-Origin来允许特定的源访问资源，前端通过XMLHttpRequest对象发送请求。

3、代理服务器：在同源策略下，通过在自己的服务器上建立代理服务器，将请求发送到目标服务器，然后将结果返回给前端。

4、WebSocket协议：WebSocket是HTML5中新添加的协议，它的设计目的是在客户端和服务器之间建立实时、双向、低延迟的通信，并且不受同源策略的限制。

5、postMessage：HTML5中的新特性，可以在跨域的窗口之间进行通信。

6、iframe跨域：利用iframe标签的src属性不受同源策略的限制，来实现跨域请求。可以通过在iframe中嵌入目标地址，然后通过iframe的contentWindow属性来获取数据。

7、nginx反向代理：通过在nginx服务器上配置反向代理，将请求转发到目标服务器，然后将结果返回给前端。
```

## CORS（跨域资源共享）有哪些种请求头且含义是什么？

```text
CORS（跨域资源共享）请求头包括以下几个：

1、Origin：表示请求来自的源地址，用于服务器端判断请求是否来自允许访问的源。

2、Access-Control-Request-Method：表示实际请求所使用的 HTTP 方法，用于服务器端判断是否允许使用该方法。

3、Access-Control-Request-Headers：表示实际请求所携带的 HTTP 头信息，用于服务器端判断是否允许携带该头信息。

4、Access-Control-Allow-Origin：表示允许访问的源地址，可以是单个地址、多个地址、全部地址（使用 * 号），用于告诉浏览器哪些来源可以进行跨域访问。

5、Access-Control-Allow-Methods：表示允许的 HTTP 方法，用于告诉浏览器哪些HTTP方法是允许跨域请求的。

6、Access-Control-Allow-Headers：表示允许的 HTTP 头信息，用于告诉浏览器哪些HTTP头信息是允许跨域请求的。

7、Access-Control-Allow-Credentials：表示是否允许发送cookie等凭证信息，用于告诉浏览器是否允许跨域请求发送凭证信息。

以上是CORS中常用的请求头，它们的含义与用法可以参考CORS规范。

```

## CORS（跨域资源共享）请求头与响应头

```text
CORS（Cross-Origin Resource Sharing，跨域资源共享）是一个机制，允许 Web 应用服务器进行跨域访问控制，从而使 Web 应用能够安全地进行跨域数据传输。通常情况下，同源策略限制了一个域名下的 JavaScript 脚本只能访问该域名下的资源。而 CORS 可以通过在 HTTP 请求头中添加特定的字段，告诉浏览器该请求允许跨域访问。这样，就可以实现跨域传输数据，同时保证了安全性。CORS 是现代 Web 应用中常用的解决跨域问题的方式之一。以下是常见的CORS请求头和响应头：

请求头：
1、Origin: 表示请求的源（即请求发出的域名），用于发起跨域请求时携带，服务器端会通过这个头来判断是否允许跨域访问。

响应头：
2、Access-Control-Allow-Origin: 表示允许访问该资源的域名，可以是具体的域名或通配符“”，如果是具体的域名，则只允许该域名访问该资源，如果是“”，则表示允许任意域名访问该资源。
3、Access-Control-Allow-Methods: 表示允许访问该资源的 HTTP 方法，可以是多个以逗号分隔的值，如“GET, POST, PUT, DELETE”。
4、Access-Control-Allow-Headers: 表示允许访问该资源的请求头，可以是多个以逗号分隔的值，如“Content-Type, Authorization”。
5、Access-Control-Expose-Headers: 表示允许客户端访问的响应头，可以是多个以逗号分隔的值，如“Content-Length, X-Custom-Header”。
以上是常见的CORS请求头和响应头，可以根据具体的需求设置不同的头信息。
```

## requestAnimationFrame 和 setInterval 的区别？

```text
1、触发时间：requestAnimationFrame的触发时间与屏幕的刷新时间同步，一般为每秒60次，而setInterval的触发时间是固定的，不受屏幕刷新时间的影响。

2、帧率控制：requestAnimationFrame会根据屏幕的刷新率自动控制帧率，避免浏览器出现卡顿、掉帧等现象，而setInterval则不能做到这一点。

3、性能消耗：requestAnimationFrame可以更好地利用浏览器的资源，因为它只在屏幕需要更新时才运行，而setInterval则会一直运行，无论屏幕是否需要更新，这会造成一定的性能消耗。

4、取消方法：requestAnimationFrame可以通过cancelAnimationFrame来取消执行，而setInterval只能通过clearInterval来取消执行。
```

## Nodejs 异步 IO 模型 (事件循环)

Nodejs 采用了基于事件驱动、异步 IO 模型。通过事件循环机制，将 IO 操作的回调函数放入事件队列中，等待执行。当事件循环发现事件队列中有回调函数时，就会调用该函数，执行相应的 IO 操作。异步 IO 模型的优点在于，在执行 IO 操作时，不会阻塞代码的执行，从而提高了程序的并发能力和响应速度。

## nodejs 中 libuv 

libuv 是一个跨平台（不同的系统平台）的异步 IO 库，它是 Nodejs 中实现异步 IO 模型的基础。
在 Nodejs 中，libuv 负责管理事件循环机制、线程池、网络 IO、文件 IO、定时器等底层操作，从而实现了高效的异步 IO 模型。libuv 还提供了一些高级功能，如进程管理、信号处理等，为 Nodejs 提供了更多的能力


## 设计模式

## 微前端





