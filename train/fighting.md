
#### 1、怎么分析性能问题？

浏览器中performance，memory内存分析，小程序如何分析

#### 2、性能指标？
页面加载时间（Page Load Time）：指从用户请求页面到页面完全加载完成的时间。

首次渲染时间（First Contentful Paint，FCP）：指页面开始渲染第一个可见元素的时间。

可交互时间（Time to Interactive，TTI）：用户可以与页面交互的时间。

总下载时间（Total Download Time）：指页面中所有资源下载所需的时间。

HTTP请求次数（HTTP Requests）：指页面中发起的HTTP请求总数。

页面大小（Page Size）：指页面中所有资源的总大小。

缓存命中率（Cache Hit Rate）：指页面资源在浏览器缓存中被访问的比例。

页面可访问性（Accessibility）：指页面是否易于访问，包括文本内容、颜色对比度等。

#### 3、稳定性？

#### 4、SSR缓存是怎么做的？

SSR缓存是指将SSR生成的HTML页面缓存起来，以便在下一次请求时直接返回缓存的HTML页面而不是重新生成。这样可以大大提高页面加载速度和减轻服务器负担。

#### 5、JS实现一个带并发的调度器(scheduler)，保证同时运行的任务最多两个，完善代码中的Scheduler类，使得一下程序能正常输出？

#### 6、webview和小程序的区别（小程序原理，渲染引擎原理）

小程序原理：
整体架构上：基于WEB规范封装的一套Hybrid应用框架，整体架构分三层视图层、逻辑层、bridge/native层，上层由渲染层和逻辑层构成，底层由bridge层来承接视图和逻辑层之前的数据传递和事件绑定。
数据传递：使用了单项数据流MVVM框架的数据驱动，让数据和视图绑定在一起，同时也使用了虚拟dom优化了对页面Dom的频繁操作带来的性能问题
![小程序架构](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dff90394f8342c68f3d0bf629ade56f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

渲染引擎原理：
当浏览器内核获取到HTML文件后，会从上自下的加载，并在加载过程中进行解析渲染，如果遇到css和图片就发起请求(此处为异步)，并不会阻塞浏览器继续渲染。而当遇到JavaScript文件时，HTML渲染会被挂起等待JavaScript执行完成，因为JavaScript可能会操作HTML dom节点的变化。所以为了避免JavaScript的执行影响GUI引擎的渲染，通常会将JavaScript代码放置在body之后。


#### 7、SSR vs SSG

SSR 是在服务器上动态生成HTML页面，它会在每个请求时动态生成页面内容。所以在高并发情况下，服务器可能会承受不住高并发的压力。
SSG 是在构建时生成静态内容的过程，这种方式可以提供更快的页面加载速度，因为页面已经预先生成好了，不需要每次请求时再生成。由于页面内容是静态的，所以可以将页面缓存在 CDN 中，进一步提高性能。
SSR 适用于需要 SEO 和动态数据的应用程序，而 SSG 适用于内容不太变化或者数据更新不太频繁的应用程序。

#### 9、有什么优化方案？（快照、端侧TabBar方案、商详预请求、串行改并行等）

为什么要小程序走H5方案：1、性能问题(首屏冷启动5s+，热启动也需要3s，首屏打开率60%) 2、工程复杂性(多人共同开发一个项目，项目分险搞) 3、更多的H5性能优化方案实践 4、跨端方案的打通与协调难
首屏性能优化：小程序迁H5方案：小程序(5s+) -> CSR(2.8s) -> SSR -> ESR(流式渲染)的升级方案，然后又做了快照、端TabBar方案、预请求方案等，打开率60%->90%
CSR：


#### 11、小程序为什么采用双线程架构？ 浏览器是单线程设计，webWorker线程安全问题？

小程序为什么采用双线程架构：
目的：体验问题(执行JS的时候会同步阻塞页面渲染，导致卡屏和白屏等情况)，解决JS单线程问题，管控（安全管控和流量管控）

浏览器是单线程设计？
浏览器是多进程多线程，浏览器管理多个浏览页面，每个浏览页面都会重启一个render进程同时初始化浏览器内核，浏览器内核中有存在多个线程，如GUI绘制线程、JS引擎线程、定时器、事件触发、异步http请求等线程。
JS线程初始化即JS引擎初始化，引擎先处理

webWorker线程安全问题：
web worker是一种主子线程模式，子线程只能做计算，不能操作dom，也不能访问浏览器存储（比如 localStorage），且子线程的执行环境和主线程的也是隔离的，从而避免了线程安全问题。（除SharedArrayBuffer内存共享，结构同arrayBuffer，可通过postMessage方法将一个SharedArrayBuffer对象从一个用户代理共享到另一个用户代理（另一个页面的主进程或者当前页面的一个worker从而实现共享内存）

#### 12、首屏性能指标（FCP/TTI等）

FSP：首屏可交互时长，代表从用户访问点击Feeds卡片到页面加载完成图片加载完成，且包括前置webview初始化整个过程。
FCP: 首屏绘制时间，从浏览器发起请求开始到浏览器开始绘制第一像素，非用户实质性看到的像素。
TTI：用户可交互时长，等页面加载完成包括图片，再静默5秒钟后，仍然没有长任务执行（占用主进程的密集运算，比如：初始化图形化绘制引擎等）。

#### 13、闭包原理（如何回收掉）


#### 14、JavaScript 内存管理和垃圾回收机制

常发生内存泄露的情况：滥用全局变量未被释放的引用、未销毁的定时器和回调函数、未释放引用的闭包、DOM引用

JavaScript引擎的垃圾收集器基本上会寻找从内存中删除的无法访问的对象，常见的垃圾收集算法：引用计数法、标记清除法
引用计数法：查找那些没有被引用的对象，如果对象没有附加引用，则可以进行垃圾回收。
标记清除法：先标记所有存在的变量打上“红”标记，然后再从JavaScript的全局对象中去遍历能够触达到的对象打上“绿”标记，最后垃圾收集器执行的时候会清理掉所有的“红”标记。


#### 14、实现一个json stringify
